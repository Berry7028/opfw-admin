<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

class BuildMigrations extends Command
{
	/**
	 * The name and signature of the console command.
	 *
	 * @var string
	 */
	protected $signature = 'build:migrations';

	/**
	 * The console command description.
	 *
	 * @var string
	 */
	protected $description = 'Attempts to build migrations from the database schema.';

	/**
	 * Create a new command instance.
	 *
	 * @return void
	 */
	public function __construct()
	{
		parent::__construct();
	}

	/**
	 * Execute the console command.
	 *
	 * @return int
	 */
	public function handle()
	{
		$this->info("Cleaning up old migrations");
		system('rm -rf ' . base_path('_migrate'));

		$this->info("Collecting table schemas");
		$schema = $this->collectSchema();

		foreach ($schema as $table => $tableSchema) {
			$path = $this->getTableMigrationPath($table);

			$this->info("Creating migration for table $table");

			$content = $this->buildTableMigration($table, $tableSchema['columns'], $tableSchema['indexes']);

			file_put_contents($path, $content);
		}

		return 0;
	}

	private function buildTableMigration(string $table, array $columns, array $indexes): string
	{
		$name = Str::studly($table);

		$content = <<<EOT
<?php
// Auto generated by the build:migrations command

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class Create{$name}Table extends Migration
{
	/**
	 * Run the migrations.
	 *
	 * @return void
	 */
	public function up()
	{
		// Make enums work pre laravel 10
		Schema::getConnection()->getDoctrineConnection()->getDatabasePlatform()->registerDoctrineTypeMapping("enum", "string");

		\$indexes = \$this->collectIndexedColumns();
		\$columns = Schema::getColumnListing("$table");

		\$func = Schema::hasTable("$table") ? "table" : "create";

		Schema::\$func("$table", function (Blueprint \$table) use (\$columns, \$indexes) {
{{up}}
		});
	}

	/**
	 * Reverse the migrations.
	 *
	 * @return void
	 */
	public function down()
	{
		Schema::dropIfExists("$table");
	}

	/**
	 * Collect all columns that are indexed in the $table table.
	 *
	 * @return array
	 */
	private function collectIndexedColumns(): array
	{
		if (!Schema::hasTable("$table")) {
			return [];
		}

		\$sm  = Schema::getConnection()->getDoctrineSchemaManager();
		\$tbl = \$sm->introspectTable("$table");

		\$indexes = array_reduce(\$tbl->getIndexes(), function (\$carry, \$index) {
			return array_merge(\$carry, \$index->getColumns());
		}, []);

		return array_values(array_unique(\$indexes));
	}
}
EOT;

		$columnsUp = [];
		$indexesUp = [];

		foreach ($columns as $column) {
			$columnName = $column['name'];

			$create = $this->buildColumnMigration($table, $column);

			if (!$create) {
				continue;
			}

			$columnsUp[] = implode("\n", [
				sprintf("\t\t\t!in_array(\"%s\", \$columns) && %s", $columnName, $create),
			]);
		}

		foreach ($indexes as $index) {
			$indexesUp[] = sprintf("\t\t\t!in_array(\"%s\", \$indexes) && \$table->index(\"%s\");", $index, $index);
		}

		$up = trim(implode("\n", $columnsUp) . "\n\n" . implode("\n", $indexesUp), "\n");

		$content = str_replace('{{up}}', $up, $content);

		return $content;
	}

	private function buildColumnMigration(string $table, array $column): ?string
	{
		$name = $column['name'];

		$type          = $column['type'];
		$options       = $column['options'];
		$nullable      = $column['nullable'];
		$default       = $column['default'];
		$autoIncrement = $column['autoIncrement'];
		$primary       = $column['primary'];

		$content = false;

		switch ($type) {
			case 'bigint':
				$content = sprintf('$table->bigInteger("%s")', $name);
				break;
			case 'binary':
			case 'blob':
				$content = sprintf('$table->binary("%s")', $name);
				break;
			case 'boolean':
				$content = sprintf('$table->boolean("%s")', $name);
				break;
			case 'char':
				$content = sprintf('$table->char("%s", %s)', $name, $options);
				break;
			case 'datetime':
				$content = sprintf('$table->dateTime("%s")', $name);
				break;
			case 'date':
				$content = sprintf('$table->date("%s")', $name);
				break;
			case 'decimal':
				$content = sprintf('$table->decimal("%s", %s)', $name, $options);
				break;
			case 'double':
				$content = sprintf('$table->double("%s", %s)', $name, $options);
				break;
			case 'enum':
				$options = str_replace("','", '", "', $options);
				$options = str_replace("'", '"', $options);

				$content = sprintf('$table->enum("%s", [%s])', $name, $options);
				break;
			case 'float':
				$content = sprintf('$table->float("%s", %s)', $name, $options);
				break;
			case 'int':
			case 'integer':
				$content = sprintf('$table->integer("%s")', $name);
				break;
			case 'longtext':
				$content = sprintf('$table->longText("%s")', $name);
				break;
			case 'mediumint':
				$content = sprintf('$table->mediumInteger("%s")', $name);
				break;
			case 'smallint':
				$content = sprintf('$table->smallInteger("%s")', $name);
				break;
			case 'varchar':
				$content = sprintf('$table->string("%s", %s)', $name, $options);
				break;
			case 'text':
				$content = sprintf('$table->text("%s")', $name);
				break;
			case 'time':
				$content = sprintf('$table->time("%s")', $name);
				break;
			case 'timestamp':
				$content = sprintf('$table->timestamp("%s")', $name);
				break;
			case 'tinyint':
				$content = sprintf('$table->tinyInteger("%s")', $name);
				break;
			case 'tinytext':
				$content = sprintf('$table->tinyText("%s")', $name);
				break;

			default:
				$this->warn("Unknown type $type for column $name");
				return null;
		}

		// Remove empty options
		$content = str_replace(', null)', ')', $content);

		if ($nullable) {
			$content .= '->nullable()';
		}

		if ($default !== null) {
			$content .= sprintf('->default("%s")', $default);
		}

		if ($autoIncrement) {
			$content .= '->autoIncrement()';
		}

		// autoIncrement implies primary
		if (!$autoIncrement && $primary) {
			$content .= '->primary()';
		}

		return $content . ';';
	}

	private function collectSchema(): ?array
	{
		$tables = DB::select("SHOW TABLES");

		if (empty($tables)) {
			return null;
		}

		$schema = [];

		foreach ($tables as $table) {
			$name = first($table);

			$schema[$name] = [
				'columns' => [],
				'indexes' => [],
			];

			$columns = DB::select("SHOW COLUMNS FROM $name");

			if (!empty($columns)) {
				$schema[$name]['columns'] = array_map(function ($column) {
					$name = $column->Field;
					$type = $column->Type;

					$options       = 'null';
					$nullable      = $column->Null === 'YES';
					$default       = $column->Default;
					$autoIncrement = $column->Extra === 'auto_increment';
					$primary       = $column->Key === 'PRI';

					if (Str::contains($type, '(')) {
						$options = Str::between($type, '(', ')');
						$type    = Str::before($type, '(');
					}

					return [
						'name'          => $name,
						'type'          => $type,
						'options'       => $options,
						'nullable'      => $nullable,
						'default'       => $default,
						'autoIncrement' => $autoIncrement,
						'primary'       => $primary,
					];
				}, $columns);
			}

			$indexes = DB::select("SHOW INDEXES FROM $name");

			if (!empty($indexes)) {
				$schema[$name]['indexes'] = array_unique(array_filter(array_map(function ($index) {
					$column = $index->Column_name;

					// We've already got the primary key from the columns
					if ($index->Key_name === 'PRIMARY') {
						return false;
					}

					return $column;
				}, $indexes)));
			}
		}

		return $schema;
	}

	private function getTableMigrationPath(string $table): string
	{
		$dir = base_path('_migrate');

		if (!is_dir($dir)) {
			mkdir($dir);
		}

		return sprintf('%s/%s_create_%s_table.php', $dir, date('Y_m_d_His'), $table);
	}
}
