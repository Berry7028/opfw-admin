<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

class BuildMigrations extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'build:migrations';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Attempts to build migrations from the database schema.';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        $this->info("Using cluster " . CLUSTER);

        $this->info("Cleaning up old migrations");
        system('rm -rf ' . base_path('_migrate'));

        $this->info("Collecting table schemas");
        $schema = $this->collectSchema();

        foreach ($schema as $table => $tableSchema) {
            $path = $this->getTableMigrationPath($table);

            $this->info("Creating migration for table $table");

            $content = $this->buildTableMigration($table, $tableSchema['columns'], $tableSchema['indexes'], $tableSchema['hasRaw'] ?? false);

            file_put_contents($path, $content);
        }

        return 0;
    }

    private function buildTableMigration(string $table, array $columns, array $indexes, bool $hasRaw = false): string
    {
        $name = Str::studly($table);

        $extraImports = "";

        if ($hasRaw) {
            $extraImports = "\nuse Illuminate\Support\Facades\DB;";
        }

        $content = <<<EOT
<?php
// Auto generated by the build:migrations command

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;$extraImports

class Create{$name}Table extends Migration
{
	/**
	 * Run the migrations.
	 *
	 * @return void
	 */
	public function up()
	{
		// Make enums work pre laravel 10
		Schema::getConnection()->getDoctrineConnection()->getDatabasePlatform()->registerDoctrineTypeMapping("enum", "string");

		\$tableExists = Schema::hasTable("$table");

		\$indexes = \$tableExists ? \$this->getIndexedColumns() : [];
		\$columns = \$tableExists ? \$this->getColumns() : [];

		\$func = \$tableExists ? "table" : "create";

		Schema::\$func("$table", function (Blueprint \$table) use (\$columns, \$indexes) {
{{up}}
		});{{up2}}
	}

	/**
	 * Reverse the migrations.
	 *
	 * @return void
	 */
	public function down()
	{
		Schema::dropIfExists("$table");
	}

	/**
	 * Get all columns.
	 *
	 * @return array
	 */
	private function getColumns(): array
	{
		\$columns = Schema::getConnection()->select("SHOW COLUMNS FROM `$table`");

		return array_map(function (\$column) {
			return \$column->Field;
		}, \$columns);
	}

	/**
	 * Get all indexed columns.
	 *
	 * @return array
	 */
	private function getIndexedColumns(): array
	{
		\$indexes = Schema::getConnection()->select("SHOW INDEXES FROM `$table` WHERE Key_name != 'PRIMARY'");

		return array_map(function (\$index) {
			return \$index->Column_name;
		}, \$indexes);
	}
}
EOT;

        $columnsUp  = [];
        $indexesUp  = [];
        $columnsUp2 = [];
        $indexesUp2 = [];

        foreach ($columns as $column) {
            $columnName = $column['name'];

            $create = $this->buildColumnMigration($table, $column);

            if (!$create) {
                continue;
            }

            if (isset($column['raw'])) {
                $columnsUp2[] = sprintf("\t\t!in_array(\"%s\", \$columns) && %s", $columnName, $create);
            } else {
                $columnsUp[] = implode("\n", [
                    sprintf("\t\t\t!in_array(\"%s\", \$columns) && %s", $columnName, $create),
                ]);
            }
        }

        foreach ($indexes as $index) {
            $column    = $index['column'];
            $generated = $index['generated'];

            if ($generated) {
                $indexesUp2[] = sprintf("\t\t!in_array(\"%s\", \$indexes) && DB::statement(\"CREATE INDEX %s ON $table (%s)\");", $column, $column, $column);
            } else {
                $indexesUp[] = sprintf("\t\t\t!in_array(\"%s\", \$indexes) && \$table->index(\"%s\");", $column, $column);
            }
        }

        $up = trim(implode("\n", $columnsUp) . "\n\n" . implode("\n", $indexesUp), "\n");

        $content = str_replace('{{up}}', $up, $content);

        if (!empty($indexesUp2) || !empty($columnsUp2)) {
            $up2 = "";

            if (!empty($columnsUp2)) {
                $up2 .= "\n\n" . implode("\n", $columnsUp2);
            }

            if (!empty($indexesUp2)) {
                $up2 .= "\n\n" . implode("\n", $indexesUp2);
            }

            $content = str_replace('{{up2}}', $up2, $content);
        }

        return $content;
    }

    private function buildColumnMigration(string $table, array $column): ?string
    {
        $name = $column['name'];

        $raw = $column['raw'] ?? null;

        if ($raw) {
            return "DB::statement(\"ALTER TABLE $table ADD COLUMN $name $raw\");";
        }

        $type          = $column['type'];
        $options       = $column['options'];
        $nullable      = $column['nullable'];
        $default       = $column['default'];
        $autoIncrement = $column['autoIncrement'];
        $primary       = $column['primary'];

        $content = false;

        switch ($type) {
            case 'bigint':
                $content = sprintf('$table->bigInteger("%s")', $name);
                break;
            case 'binary':
            case 'blob':
                $content = sprintf('$table->binary("%s")', $name);
                break;
            case 'boolean':
                $content = sprintf('$table->boolean("%s")', $name);
                break;
            case 'char':
                $content = sprintf('$table->char("%s", %s)', $name, $options);
                break;
            case 'datetime':
                $content = sprintf('$table->dateTime("%s")', $name);
                break;
            case 'date':
                $content = sprintf('$table->date("%s")', $name);
                break;
            case 'decimal':
                $content = sprintf('$table->decimal("%s", %s)', $name, $options);
                break;
            case 'double':
                $content = sprintf('$table->double("%s", %s)', $name, $options);
                break;
            case 'enum':
                $options = str_replace("','", '", "', $options);
                $options = str_replace("'", '"', $options);

                $content = sprintf('$table->enum("%s", [%s])', $name, $options);
                break;
            case 'float':
                $content = sprintf('$table->float("%s", %s)', $name, $options);
                break;
            case 'int':
            case 'integer':
                $content = sprintf('$table->integer("%s")', $name);
                break;
            case 'longtext':
                $content = sprintf('$table->longText("%s")', $name);
                break;
            case 'mediumint':
                $content = sprintf('$table->mediumInteger("%s")', $name);
                break;
            case 'smallint':
                $content = sprintf('$table->smallInteger("%s")', $name);
                break;
            case 'varchar':
                $content = sprintf('$table->string("%s", %s)', $name, $options);
                break;
            case 'text':
                $content = sprintf('$table->text("%s")', $name);
                break;
            case 'time':
                $content = sprintf('$table->time("%s")', $name);
                break;
            case 'timestamp':
                $content = sprintf('$table->timestamp("%s")', $name);
                break;
            case 'tinyint':
                $content = sprintf('$table->tinyInteger("%s")', $name);
                break;
            case 'tinytext':
                $content = sprintf('$table->tinyText("%s")', $name);
                break;

            default:
                $this->warn("Unknown type $type for column $name");
                return null;
        }

        // Remove empty options
        $content = str_replace(', null)', ')', $content);

        if ($nullable) {
            $content .= '->nullable()';
        }

        if ($default === 'current_timestamp()') {
            $content .= '->useCurrent()';
        } else if ($default !== null) {
            $content .= sprintf('->default("%s")', $default);
        }

        if ($autoIncrement) {
            $content .= '->autoIncrement()';
        }

        // autoIncrement implies primary
        if (!$autoIncrement && $primary) {
            $content .= '->primary()';
        }

        return $content . ';';
    }

    private function collectSchema(): ?array
    {
        $tables = DB::select("SHOW TABLES");

        if (empty($tables)) {
            return null;
        }

        $schema = [];

        foreach ($tables as $table) {
            $name = first($table);

            $schema[$name] = [
                'columns' => [],
                'indexes' => [],
            ];

            $columns = DB::select("SHOW COLUMNS FROM $name");

            if (!empty($columns)) {
                $schema[$name]['columns'] = array_values(array_filter(array_map(function ($column) {
                    $name = $column->Field;
                    $type = $column->Type;

                    $options       = 'null';
                    $nullable      = $column->Null === 'YES';
                    $default       = $column->Default;
                    $autoIncrement = $column->Extra === 'auto_increment';
                    $primary       = $column->Key === 'PRI';
                    $generated     = $column->Extra === 'STORED GENERATED';

                    if ($generated) {
                        return null;
                    }

                    if (Str::contains($type, '(')) {
                        $options = Str::between($type, '(', ')');
                        $type    = Str::before($type, '(');
                    }

                    return [
                        'name'          => $name,
                        'type'          => $type,
                        'options'       => $options,
                        'nullable'      => $nullable,
                        'default'       => $default,
                        'autoIncrement' => $autoIncrement,
                        'primary'       => $primary,
                    ];
                }, $columns)));
            }

            $create = first(DB::select("SHOW CREATE TABLE $name"));

            if (!$create) {
                $this->warn("Could not find create statement for $name");

                continue;
            }

            $create = $create->{'Create Table'};

            preg_match_all('/^\s+`(\w+)` (.+? GENERATED .+?)$/m', $create, $matches, PREG_SET_ORDER, 0);

            $generatedColumns = [];

            foreach ($matches as $match) {
                if (sizeof($match) < 2) {
                    continue;
                }

                $column     = $match[1];
                $definition = $match[2];

                if (Str::endsWith($definition, ',')) {
                    $definition = Str::beforeLast($definition, ',');
                }

                $schema[$name]['columns'][] = [
                    'name' => $column,
                    'raw'  => $definition,
                ];

                $schema[$name]['hasRaw'] = true;

                $generatedColumns[] = $column;
            }

            $indexes = DB::select("SHOW INDEXES FROM $name");

            if (!empty($indexes)) {
                $added = [];

                $schema[$name]['indexes'] = array_values(array_filter(array_map(function ($index) use ($generatedColumns) {
                    $column = $index->Column_name;

                    // We've already got the primary key from the columns
                    if ($index->Key_name === 'PRIMARY') {
                        return false;
                    }

                    return [
                        'column'    => $column,
                        'generated' => in_array($column, $generatedColumns),
                    ];
                }, $indexes), function ($index) use (&$added) {
                    if (!$index || in_array($index['column'], $added)) {
                        return false;
                    }

                    $added[] = $index['column'];

                    return true;
                }));
            }
        }

        return $schema;
    }

    private function getTableMigrationPath(string $table): string
    {
        $dir = base_path('_migrate');

        if (!is_dir($dir)) {
            mkdir($dir);
        }

        return sprintf('%s/%s_create_%s_table.php', $dir, date('Y_m_d_His'), $table);
    }
}
